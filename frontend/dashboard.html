<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dashboard ‚Ä¢ Tomorrow's News</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="/app/assets/theme.css" rel="stylesheet" />
</head>

<body class="bg-light">
    <nav class="navbar navbar-expand-lg navbar-light bg-white border-bottom">
        <div class="container">
            <a class="navbar-brand text-primary" href="/app/dashboard.html">Tomorrow's News</a>
            <div class="d-flex ms-auto">
                <button id="logout" class="btn btn-outline-secondary">Logout</button>
            </div>
        </div>
    </nav>

    <main class="container py-5">
        <div class="main-container">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <div class="d-flex align-items-center">
                    <div class="icon-placeholder icon-topic me-3">üìë</div>
                    <h1 class="h3 mb-0 fw-semibold">Your Topics</h1>
                </div>
                <div class="d-flex align-items-center gap-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="collapse-all-switch" checked>
                        <label class="form-check-label small" for="collapse-all-switch"
                            title="Expand or collapse all topics at once">Expand all topics</label>
                    </div>
                    <a class="btn btn-primary" href="/app/topic-new.html"
                        title="Create a new topic to track events about">‚ûï New Topic</a>
                </div>
            </div>
            <div id="alert" class="alert d-none" role="alert"></div>
            <div id="topics" class="vstack gap-4"></div>
        </div>
    </main>

    <script type="module" src="/app/js/config.js"></script>
    <script type="module">
        import { apiBase, getToken, authHeaders, clearToken } from '/app/js/config.js';
        const alertEl = document.getElementById('alert');
        const token = getToken();
        if (!token) { window.location.href = '/app/login.html'; }

        document.getElementById('logout').onclick = () => { clearToken(); window.location.href = '/app/login.html'; };

        async function fetchTopics() {
            try {
                const resp = await fetch(`${apiBase}/topics/?limit=100`, { headers: authHeaders() });
                if (!resp.ok) throw new Error('Failed to load topics');
                const topics = await resp.json();
                // Fetch sources, initial upcoming events, and event counts for each topic in parallel
                const [sourcesPairs, eventsPairs, countPairs] = await Promise.all([
                    Promise.all(topics.map(async (t) => {
                        try { return [t.id, await fetchSources(t.id)]; } catch { return [t.id, []]; }
                    })),
                    Promise.all(topics.map(async (t) => {
                        try { return [t.id, await fetchUpcomingEvents(t.id, 20, true, 0)]; } catch { return [t.id, []]; }
                    })),
                    Promise.all(topics.map(async (t) => {
                        try { return [t.id, await fetchEventsCount(t.id)]; } catch { return [t.id, 0]; }
                    })),
                ]);
                const sourcesByTopic = Object.fromEntries(sourcesPairs);
                const eventsByTopic = Object.fromEntries(eventsPairs);
                const countsByTopic = Object.fromEntries(countPairs);
                renderTopics(topics, sourcesByTopic, eventsByTopic, countsByTopic);
                startPolling(topics.map(t => t.id));
                // Initialize global collapse switch state
                setTimeout(updateCollapseAllSwitch, 100);
            } catch (err) {
                alertEl.textContent = err.message || 'Failed to load topics';
                alertEl.className = 'alert alert-danger';
            }
        }

        async function fetchSources(topicId) {
            const resp = await fetch(`${apiBase}/scraping-sources/?topic_id=${encodeURIComponent(topicId)}&limit=100`, { headers: authHeaders() });
            if (!resp.ok) throw new Error('Failed to load sources');
            return await resp.json();
        }

        async function fetchUpcomingEvents(topicId, limit = 20, includeExtracted = true, skip = 0) {
            const params = new URLSearchParams({
                topic_id: String(topicId),
                limit: String(limit),
                skip: String(skip),
            });
            if (includeExtracted) params.set('include_extracted', 'true');
            const resp = await fetch(`${apiBase}/events/?${params.toString()}`, { headers: authHeaders() });
            if (!resp.ok) throw new Error('Failed to load events');
            return await resp.json();
        }

        async function fetchEventsCount(topicId) {
            const params = new URLSearchParams({
                topic_id: String(topicId),
                limit: '1000', // High limit to get all events for counting
                skip: '0',
            });
            const resp = await fetch(`${apiBase}/events/?${params.toString()}`, { headers: authHeaders() });
            if (!resp.ok) throw new Error('Failed to load events count');
            const events = await resp.json();
            return events.length;
        }

        const topicState = {};

        // Helper function to extract domain from URL
        function extractDomain(url) {
            try {
                const domain = new URL(url).hostname;
                // Remove 'www.' prefix and capitalize first letter
                const cleanDomain = domain.replace(/^www\./, '');
                return cleanDomain.charAt(0).toUpperCase() + cleanDomain.slice(1);
            } catch (e) {
                return 'Unknown';
            }
        }

        // Helper function to format time differences in a human-readable way
        function formatTimeAgo(milliseconds) {
            const seconds = Math.floor(Math.abs(milliseconds) / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) {
                return `${days} day${days === 1 ? '' : 's'}`;
            } else if (hours > 0) {
                return `${hours} hour${hours === 1 ? '' : 's'}`;
            } else if (minutes > 0) {
                return `${minutes} minute${minutes === 1 ? '' : 's'}`;
            } else {
                return `${seconds} second${seconds === 1 ? '' : 's'}`;
            }
        }

        // Sort state: default to date ascending
        const sortState = {
            field: 'date',      // 'date' or 'significance'
            direction: 'asc'    // 'asc' or 'desc'
        };

        function sortEvents(events, field = 'date', direction = 'asc') {
            const sortedEvents = [...events].sort((a, b) => {
                let valueA, valueB;

                if (field === 'date') {
                    valueA = new Date(a.date);
                    valueB = new Date(b.date);
                } else if (field === 'significance') {
                    valueA = a.significance || 0;
                    valueB = b.significance || 0;
                }

                if (direction === 'asc') {
                    return valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
                } else {
                    return valueA < valueB ? 1 : valueA > valueB ? -1 : 0;
                }
            });

            return sortedEvents;
        }

        function renderTopics(topics, sourcesByTopic, eventsByTopic, countsByTopic) {
            const container = document.getElementById('topics');
            container.innerHTML = '';
            if (!topics.length) {
                container.innerHTML = '<div class="text-secondary">No topics yet.</div>';
                return;
            }
            topics.forEach((t) => {
                const card = document.createElement('div');
                card.className = 'card topic-card';
                card.innerHTML = `
            <div class="card-body">
              <div class="topic-header d-flex justify-content-between align-items-center" id="topic-header-${t.id}" role="button" tabindex="0" title="Click to expand or collapse this topic">
                <div class="d-flex align-items-center flex-grow-1">
                  <div class="icon-placeholder icon-topic me-3">üìë</div>
                  <div class="flex-grow-1">
                    <h2 class="h5 mb-1">${t.name}</h2>
                    <div class="d-flex align-items-center gap-2 text-secondary small">
                      <span>${t.description
                        ? t.description.length > 55
                            ? t.description.slice(0, 55) + '...'
                            : t.description
                        : ''
                    }</span>
                      <span class="topic-stats" id="topic-stats-${t.id}"></span>
                    </div>
                  </div>
                </div>
                <div class="ms-3 flex-shrink-0 d-flex align-items-center gap-2">
                  <div class="topic-gear-menu" id="topic-gear-${t.id}">
                    <button class="btn btn-icon btn-outline-secondary topic-gear-btn" title="Topic actions">
                      ‚öôÔ∏è
                    </button>
                    <div class="topic-gear-dropdown">
                      <a class="dropdown-item" href="/app/topic-edit.html?id=${t.id}">
                        <span class="dropdown-icon">‚úèÔ∏è</span>
                        Edit Topic
                      </a>
                      <a class="dropdown-item" href="/app/feed-new.html?topic_id=${t.id}">
                        <span class="dropdown-icon">‚ûï</span>
                        Add Feed
                      </a>
                    </div>
                  </div>
                  <div class="collapse-indicator" id="collapse-indicator-${t.id}">
                    <span class="collapse-arrow">‚ñº</span>
                  </div>
                </div>
              </div>
              
              <div class="collapse show" id="topic-content-${t.id}">
                <div class="d-flex justify-content-between align-items-center mt-4 mb-3">
                  <h3 class="h6 mb-0 d-flex align-items-center">
                    <div class="icon-placeholder icon-topic me-2">üì°</div>
                    <span>Feeds <span class="text-muted" id="feeds-count-${t.id}"></span></span>
                  </h3>
                  <div class="control-group">
                                          <div class="form-check form-switch form-switch-compact">
                        <input class="form-check-input" type="checkbox" id="sources-expand-${t.id}" checked>
                        <label class="form-check-label" for="sources-expand-${t.id}" title="Show or hide the list of feeds for this topic">Expand</label>
                      </div>
                  </div>
                </div>
                <div class="collapse show" id="sources-content-${t.id}">
                  <div id="sources-${t.id}"></div>
                </div>
                <hr class="my-4" />
                <div class="mb-3">
                  <div class="events-header d-flex justify-content-between align-items-center mb-3">
                    <h3 class="h6 mb-0 d-flex align-items-center">
                      <div class="icon-placeholder icon-event me-2">üìÖ</div>
                      <span>Upcoming events <span class="text-muted" id="events-count-${t.id}"></span></span>
                    </h3>
                    <div class="d-flex align-items-center gap-2">
                      <button class="btn btn-sm btn-outline-secondary events-controls-btn" id="events-controls-btn-${t.id}" title="Event display options">
                        ‚öôÔ∏è Options
                      </button>
                      <div class="form-check form-switch form-switch-compact">
                        <input class="form-check-input" type="checkbox" id="events-expand-${t.id}">
                        <label class="form-check-label" for="events-expand-${t.id}" title="Show or hide the list of events for this topic">Expand</label>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Collapsible controls panel -->
                  <div class="events-controls-panel collapse" id="events-controls-panel-${t.id}">
                    <div class="controls-panel-content">
                      <div class="row g-3">
                        <div class="col-md-3">
                          <label class="form-label small">Sort by:</label>
                          <select class="form-select form-select-sm event-sort-field" id="sort-field-${t.id}" title="Choose what to sort events by">
                            <option value="date">Date</option>
                            <option value="significance">Significance</option>
                          </select>
                        </div>
                        <div class="col-md-3">
                          <label class="form-label small">Order:</label>
                          <button class="btn btn-sm btn-outline-secondary w-100 event-sort-direction" id="sort-direction-${t.id}" title="Toggle sort direction">
                            <span class="sort-text">Ascending</span>
                          </button>
                        </div>
                        <div class="col-md-3">
                          <label class="form-label small">View:</label>
                          <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="minimal-view-${t.id}">
                            <label class="form-check-label" for="minimal-view-${t.id}" title="Toggle between full and minimal event display">Minimal view</label>
                          </div>
                        </div>
                        <div class="col-md-3">
                          <label class="form-label small">Sources:</label>
                          <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="toggle-all-sources-${t.id}">
                            <label class="form-check-label" for="toggle-all-sources-${t.id}" title="Show events from all sources or just primary ones">Show all sources</label>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="collapse" id="events-content-${t.id}">
                  <div id="events-${t.id}"></div>
                  <div class="d-grid mt-3">
                    <button class="btn btn-outline-secondary btn-sm" id="show-more-${t.id}" title="Load additional events for this topic">Show more</button>
                  </div>
                </div>
              </div>
            </div>
          `;
                container.appendChild(card);
                const sources = sourcesByTopic[t.id] || [];
                const sEl = card.querySelector(`#sources-${t.id}`);
                if (!sources.length) {
                    sEl.innerHTML = '<div class="text-secondary">No sources.</div>';
                    // Update feeds count for empty case
                    const feedsCountEl = card.querySelector(`#feeds-count-${t.id}`);
                    feedsCountEl.textContent = '';
                }
                const list = document.createElement('div');
                list.className = 'list-group list-group-flush';
                sources.forEach((s, index) => {
                    const iconMap = { 'Webpage': 'üåê', 'Rss': 'üì°', 'Api': 'üîó' };
                    const iconClass = s.source_type === 'Webpage' ? 'icon-web' : s.source_type === 'Rss' ? 'icon-rss' : 'icon-api';

                    // Calculate status indicators based on scraping schedule
                    const lastScrapedDate = s.last_scraped_at ? new Date(s.last_scraped_at) : null;
                    const now = new Date();
                    const scrapingFrequencyMs = (s.scraping_frequency || 60) * 60 * 1000; // Convert minutes to milliseconds
                    let statusIndicator = '';
                    let statusClass = '';
                    let statusDot = '';

                    if (lastScrapedDate && lastScrapedDate.getFullYear() > 1900) {
                        const nextDueDate = new Date(lastScrapedDate.getTime() + scrapingFrequencyMs);
                        const timeSinceLastScrape = now - lastScrapedDate;
                        const timeUntilNextDue = nextDueDate - now;

                        // Format last scraped time
                        const lastScrapedFormatted = formatTimeAgo(timeSinceLastScrape);

                        // Format next due time
                        let nextDueFormatted;
                        if (timeUntilNextDue > 0) {
                            nextDueFormatted = `Due in ${formatTimeAgo(timeUntilNextDue)}`;
                        } else {
                            nextDueFormatted = `Overdue by ${formatTimeAgo(Math.abs(timeUntilNextDue))}`;
                        }

                        // Check if currently scraping from the backend data
                        const isCurrentlyScraping = s.currently_scraping || false;

                        if (isCurrentlyScraping) {
                            statusDot = 'üü°';
                            statusIndicator = `Currently scraping ‚Ä¢ Last: ${lastScrapedFormatted} ago`;
                            statusClass = 'status-scraping';
                        } else if (timeUntilNextDue > 0) {
                            // Not overdue - green dot
                            statusDot = 'üü¢';
                            statusIndicator = `Last: ${lastScrapedFormatted} ago ‚Ä¢ ${nextDueFormatted}`;
                            statusClass = 'status-scheduled';
                        } else {
                            // Overdue - red dot
                            statusDot = 'üî¥';
                            statusIndicator = `Last: ${lastScrapedFormatted} ago ‚Ä¢ ${nextDueFormatted}`;
                            statusClass = 'status-overdue';
                        }
                    } else {
                        const isCurrentlyScraping = s.currently_scraping || false;
                        if (isCurrentlyScraping) {
                            statusDot = 'üü°';
                            statusIndicator = 'Currently scraping ‚Ä¢ Last: never';
                            statusClass = 'status-scraping';
                        } else {
                            statusDot = '‚ö™';
                            statusIndicator = 'Never scraped';
                            statusClass = 'status-never';
                        }
                    }

                    const row = document.createElement('div');
                    row.className = `feed-item ${statusClass}`;

                    row.innerHTML = `
                        <div class="feed-content">
                            <div class="d-flex align-items-center">
                                <div class="icon-placeholder ${iconClass} me-3">${iconMap[s.source_type] || 'üîó'}</div>
                                <div class="flex-grow-1">
                                    <div class="d-flex align-items-center gap-2 mb-1">
                                        <span class="fw-semibold">${s.name}</span>
                                        <span class="badge text-bg-light">${s.source_type}</span>
                                        <span class="feed-status ${statusClass}">${statusDot} ${statusIndicator}</span>
                                    </div>
                                    <div class="small text-secondary">${s.base_url}</div>
                                </div>
                            </div>
                            <div class="feed-actions">
                                <a class="btn btn-icon btn-outline-secondary feed-edit-btn" href="/app/feed-edit.html?id=${s.id}" title="Edit settings and configuration for this feed">
                                    ‚úèÔ∏è
                                </a>
                            </div>
                        </div>
                        ${index < sources.length - 1 ? '<div class="feed-separator"></div>' : ''}
                    `;

                    list.appendChild(row);
                });
                sEl.innerHTML = '';
                sEl.appendChild(list);

                // Update feeds count
                const feedsCountEl = card.querySelector(`#feeds-count-${t.id}`);
                feedsCountEl.textContent = sources.length > 0 ? `(${sources.length})` : '';

                // Update topic stats in header
                const topicStatsEl = card.querySelector(`#topic-stats-${t.id}`);
                const totalCount = countsByTopic[t.id] || 0;
                const sourcesCount = sources.length;
                const statsText = [];
                if (sourcesCount > 0) statsText.push(`üì° ${sourcesCount} feed${sourcesCount > 1 ? 's' : ''}`);
                if (totalCount > 0) statsText.push(`üìÖ ${totalCount} event${totalCount > 1 ? 's' : ''}`);
                topicStatsEl.textContent = statsText.length > 0 ? `‚Ä¢ ${statsText.join(' ‚Ä¢ ')}` : '';

                // Initialize topic state
                topicState[t.id] = topicState[t.id] || { limit: 20, skip: 0, showSourcesGlobal: false, expanded: new Set(), events: [], totalCount: 0, minimalView: false, expandedInMinimal: new Set(), isExpanded: true };
                topicState[t.id].events = eventsByTopic[t.id] || [];
                topicState[t.id].totalCount = countsByTopic[t.id] || 0;

                // Render events
                renderEventsForTopic(t.id);

                // Wire global toggle
                const toggleAll = card.querySelector(`#toggle-all-sources-${t.id}`);
                toggleAll.checked = topicState[t.id].showSourcesGlobal;
                toggleAll.onchange = () => {
                    topicState[t.id].showSourcesGlobal = !!toggleAll.checked;
                    renderEventsForTopic(t.id);
                };

                // Wire minimal view toggle
                const minimalToggle = card.querySelector(`#minimal-view-${t.id}`);
                minimalToggle.checked = topicState[t.id].minimalView;
                minimalToggle.onchange = () => {
                    topicState[t.id].minimalView = !!minimalToggle.checked;
                    // Clear individual expansion state when toggling minimal view off or on
                    // This ensures a clean slate when re-entering minimal view
                    topicState[t.id].expandedInMinimal.clear();
                    renderEventsForTopic(t.id);
                };

                // Wire Show more
                const showMoreBtn = card.querySelector(`#show-more-${t.id}`);
                showMoreBtn.onclick = async () => {
                    try {
                        const currentSkip = topicState[t.id].events.length + 1;
                        const [newEvents, newCount] = await Promise.all([
                            fetchUpcomingEvents(t.id, 20, true, currentSkip),
                            fetchEventsCount(t.id)
                        ]);
                        topicState[t.id].events = topicState[t.id].events.concat(newEvents);
                        topicState[t.id].totalCount = newCount;
                        renderEventsForTopic(t.id);
                    } catch (e) {
                        console.error(e);
                    }
                };

                // Wire header click functionality for collapse/expand
                const topicContent = card.querySelector(`#topic-content-${t.id}`);
                const topicHeader = card.querySelector(`#topic-header-${t.id}`);
                const collapseIndicator = card.querySelector(`#collapse-indicator-${t.id} .collapse-arrow`);
                const gearMenu = card.querySelector(`#topic-gear-${t.id}`);

                // Function to toggle topic expansion
                function toggleTopicExpansion() {
                    const isExpanded = topicState[t.id].isExpanded;
                    topicState[t.id].isExpanded = !isExpanded;

                    if (topicState[t.id].isExpanded) {
                        topicContent.classList.add('show');
                        collapseIndicator.textContent = '‚ñº';
                        topicHeader.setAttribute('aria-expanded', 'true');
                    } else {
                        topicContent.classList.remove('show');
                        collapseIndicator.textContent = '‚ñ∂';
                        topicHeader.setAttribute('aria-expanded', 'false');
                    }
                    setTimeout(updateCollapseAllSwitch, 100);
                }

                // Wire header click (but not gear menu clicks)
                topicHeader.onclick = (e) => {
                    if (!gearMenu.contains(e.target)) {
                        toggleTopicExpansion();
                    }
                };

                // Wire keyboard support
                topicHeader.onkeydown = (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        if (!gearMenu.contains(e.target)) {
                            toggleTopicExpansion();
                        }
                    }
                };

                // Wire gear menu toggle
                const gearBtn = gearMenu.querySelector('.topic-gear-btn');
                const gearDropdown = gearMenu.querySelector('.topic-gear-dropdown');

                gearBtn.onclick = (e) => {
                    e.stopPropagation();
                    gearMenu.classList.toggle('show');
                };

                // Close gear menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!gearMenu.contains(e.target)) {
                        gearMenu.classList.remove('show');
                    }
                });

                // Set initial state
                topicHeader.setAttribute('aria-expanded', topicState[t.id].isExpanded ? 'true' : 'false');
                collapseIndicator.textContent = topicState[t.id].isExpanded ? '‚ñº' : '‚ñ∂';

                // Wire sources collapse switch
                const sourcesContent = card.querySelector(`#sources-content-${t.id}`);
                const sourcesSwitch = card.querySelector(`#sources-expand-${t.id}`);
                const sourcesLabel = card.querySelector(`label[for="sources-expand-${t.id}"]`);

                sourcesSwitch.onchange = () => {
                    if (sourcesSwitch.checked) {
                        sourcesContent.classList.add('show');
                        sourcesLabel.textContent = 'Expand';
                    } else {
                        sourcesContent.classList.remove('show');
                        sourcesLabel.textContent = 'Collapse';
                    }
                };

                // Wire events collapse switch
                const eventsContent = card.querySelector(`#events-content-${t.id}`);
                const eventsSwitch = card.querySelector(`#events-expand-${t.id}`);
                const eventsLabel = card.querySelector(`label[for="events-expand-${t.id}"]`);

                eventsSwitch.onchange = () => {
                    if (eventsSwitch.checked) {
                        eventsContent.classList.add('show');
                        eventsLabel.textContent = 'Collapse';
                    } else {
                        eventsContent.classList.remove('show');
                        eventsLabel.textContent = 'Expand';
                    }
                };

                // Wire controls panel toggle
                const controlsBtn = card.querySelector(`#events-controls-btn-${t.id}`);
                const controlsPanel = card.querySelector(`#events-controls-panel-${t.id}`);

                controlsBtn.onclick = () => {
                    const isOpen = controlsPanel.classList.contains('show');
                    if (isOpen) {
                        controlsPanel.classList.remove('show');
                        controlsBtn.textContent = '‚öôÔ∏è Options';
                    } else {
                        controlsPanel.classList.add('show');
                        controlsBtn.textContent = '‚öôÔ∏è Hide Options';
                    }
                };

                // Wire sorting controls
                const sortFieldSelect = card.querySelector(`#sort-field-${t.id}`);
                const sortDirectionBtn = card.querySelector(`#sort-direction-${t.id}`);
                const sortText = sortDirectionBtn.querySelector('.sort-text');

                // Initialize topic sorting state
                if (!topicState[t.id].sortField) {
                    topicState[t.id].sortField = sortState.field;
                    topicState[t.id].sortDirection = sortState.direction;
                }

                // Set initial UI state
                sortFieldSelect.value = topicState[t.id].sortField;
                sortText.textContent = topicState[t.id].sortDirection === 'asc' ? 'Ascending' : 'Descending';
                sortDirectionBtn.title = `Sort ${topicState[t.id].sortDirection === 'asc' ? 'ascending' : 'descending'}`;

                // Sort field change handler
                sortFieldSelect.onchange = () => {
                    topicState[t.id].sortField = sortFieldSelect.value;
                    renderEventsForTopic(t.id);
                };

                // Sort direction toggle handler
                sortDirectionBtn.onclick = () => {
                    const currentDirection = topicState[t.id].sortDirection;
                    const newDirection = currentDirection === 'asc' ? 'desc' : 'asc';
                    topicState[t.id].sortDirection = newDirection;

                    // Update UI
                    sortText.textContent = newDirection === 'asc' ? 'Ascending' : 'Descending';
                    sortDirectionBtn.title = `Sort ${newDirection === 'asc' ? 'ascending' : 'descending'}`;

                    renderEventsForTopic(t.id);
                };
            });
        }

        function renderEventsForTopic(topicId) {
            const container = document.querySelector(`#events-${topicId}`);
            const data = topicState[topicId];
            const rawEvents = data.events || [];
            if (!rawEvents.length) {
                container.innerHTML = '<div class="text-secondary">No upcoming events.</div>';
                // Update events count
                const eventsCountEl = document.querySelector(`#events-count-${topicId}`);
                eventsCountEl.textContent = '';
                return;
            }

            // Apply sorting
            const sortField = data.sortField || sortState.field;
            const sortDirection = data.sortDirection || sortState.direction;
            const events = sortEvents(rawEvents, sortField, sortDirection);
            const eventsContainer = document.createElement('div');
            eventsContainer.className = 'vstack gap-3';
            const isMinimalView = data.minimalView || false;
            events.forEach(ev => {
                const evId = ev.id;
                const expanded = data.expanded.has(evId) || data.showSourcesGlobal;
                const expandedInMinimal = data.expandedInMinimal.has(evId);
                const dateStr = new Date(ev.date).toLocaleDateString('en-US', {
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
                const addl = ev.additional_infos && Object.entries(ev.additional_infos).length
                    ? Object.entries(ev.additional_infos).map(([k, v]) => `<span class="badge text-bg-light me-1 mb-1">"${k}: ${v}"</span>`).join(' ')
                    : '';

                // Determine confidence level styling
                const confidence = Math.round((ev.significance || 0) * 100);
                let confidenceClass = 'confidence-low';
                if (confidence >= 70) confidenceClass = 'confidence-high';
                else if (confidence >= 60) confidenceClass = 'confidence-medium';

                const eventDiv = document.createElement('div');
                eventDiv.className = 'event-item';

                if (isMinimalView && !expandedInMinimal) {
                    // Minimal view: only title, date, and location (clickable to expand)
                    eventDiv.className += ' event-item-minimal-clickable';
                    eventDiv.style.cursor = 'pointer';
                    eventDiv.innerHTML = `
                        <div class="d-flex align-items-center gap-3">
                          <div class="icon-placeholder icon-event flex-shrink-0">üìÖ</div>
                          <div class="flex-grow-1 min-w-0">
                            <h4 class="h6 mb-1 fw-semibold">${ev.title}</h4>
                            <div class="small text-secondary">
                              <span class="fw-medium">üìÖ ${dateStr}</span>
                              ${ev.location ? ` ‚Ä¢ <span class="fw-medium">üìç ${ev.location}</span>` : ''}
                            </div>
                          </div>
                          <div class="flex-shrink-0">
                            <span class="confidence-badge ${confidenceClass}" title="Significance rating for this event, based on the nature of the event, its importance to the topic, and the likelihood of the event coming to pass">${confidence}%</span>
                          </div>
                        </div>
                    `;
                } else {
                    // Full view (either not minimal mode or expanded in minimal mode)
                    if (isMinimalView && expandedInMinimal) {
                        eventDiv.className += ' event-item-expanded-in-minimal';
                        eventDiv.style.cursor = 'pointer';
                    }
                    // TODO: remove false && to re-activate additional infos
                    eventDiv.innerHTML = `
                        <div class="d-flex align-items-start gap-3">
                          <div class="icon-placeholder icon-event flex-shrink-0">üìÖ</div>
                          <div class="flex-grow-1 min-w-0">
                            <div class="d-flex justify-content-between align-items-start mb-2">
                              <div class="flex-grow-1 min-w-0 me-3">
                                <h4 class="h6 mb-1 fw-semibold">${ev.title} ${isMinimalView && expandedInMinimal ? '<small class="text-muted">(click to collapse)</small>' : ''}</h4>
                                <div class="small text-secondary mb-2">
                                  <span class="fw-medium">üìÖ ${dateStr}</span>
                                  ${ev.location ? ` ‚Ä¢ <span class="fw-medium">üìç ${ev.location}</span>` : ''}
                                </div>
                              </div>
                              <div class="flex-shrink-0">
                                <span class="confidence-badge ${confidenceClass}" title="Significance rating for this event, based on the nature of the event, its importance to the topic, and the likelihood of the event coming to pass">${confidence}%</span>
                              </div>
                            </div>
                            ${ev.description ? `<div class="mb-3 fw-medium text-dark text-overflow-container">${ev.description}</div>` : ''}
                            ${false && addl ? `<div class="mb-2 text-overflow-container"><small class="text-muted fw-medium">Additional Info:</small><br/><div class="badge-container">${addl}</div></div>` : ''}
                            ${(!isMinimalView || (isMinimalView && expandedInMinimal)) ? `<div class="event-expand-hint text-end">
                              <small class="text-muted cursor-pointer event-sources-toggle" data-event-id="${evId}">
                                ${expanded ? 'üëÅÔ∏è Click to hide sources' : 'üëÅÔ∏è Click to show sources'}
                              </small>
                            </div>` : ''}
                          </div>
                        </div>
                        ${(!isMinimalView || (isMinimalView && expandedInMinimal)) ? `<div class="mt-3 ${expanded ? '' : 'd-none'}" id="ev-sources-${evId}"></div>` : ''}
                    `;
                }
                eventsContainer.appendChild(eventDiv);

                // Add click handlers for minimal view expansion/collapse
                if (isMinimalView) {
                    eventDiv.onclick = () => {
                        if (expandedInMinimal) {
                            // Collapse this event
                            data.expandedInMinimal.delete(evId);
                        } else {
                            // Expand this event
                            data.expandedInMinimal.add(evId);
                        }
                        renderEventsForTopic(topicId);
                    };
                }

                // Add source toggle functionality if not in minimal view OR if expanded in minimal view
                if (!isMinimalView || (isMinimalView && expandedInMinimal)) {
                    // Render extracted events list
                    const tgt = eventDiv.querySelector(`#ev-sources-${evId}`);
                    if (tgt) {
                        renderExtractedEvents(tgt, ev.extracted_events || []);
                    }

                    // Wire progressive disclosure - click anywhere on event (except minimal view clicks)
                    const sourceToggle = eventDiv.querySelector('.event-sources-toggle');
                    if (sourceToggle) {
                        sourceToggle.onclick = (e) => {
                            e.stopPropagation();
                            const isCurrentlyExpanded = data.expanded.has(evId) || data.showSourcesGlobal;

                            if (isCurrentlyExpanded) {
                                data.expanded.delete(evId);
                            } else {
                                data.expanded.add(evId);
                            }
                            renderEventsForTopic(topicId);
                        };
                    }

                    // Also make the entire event card clickable (but not in minimal view to avoid conflicts)
                    if (!isMinimalView) {
                        eventDiv.style.cursor = 'pointer';
                        eventDiv.onclick = (e) => {
                            // Only trigger if clicking on the event itself, not on links or buttons
                            if (!e.target.closest('a') && !e.target.closest('button') && !e.target.closest('.event-sources-toggle')) {
                                const isCurrentlyExpanded = data.expanded.has(evId) || data.showSourcesGlobal;

                                if (isCurrentlyExpanded) {
                                    data.expanded.delete(evId);
                                } else {
                                    data.expanded.add(evId);
                                }
                                renderEventsForTopic(topicId);
                            }
                        };
                    }
                }
            });
            container.innerHTML = '';
            container.appendChild(eventsContainer);

            // Update events count - use total count, not just displayed events
            const eventsCountEl = document.querySelector(`#events-count-${topicId}`);
            const totalCount = data.totalCount || 0;
            eventsCountEl.textContent = totalCount > 0 ? `(${totalCount})` : '';
        }

        function renderExtractedEvents(container, extracted) {
            if (!extracted.length) {
                container.innerHTML = '<div class="text-secondary small">No sources for this event.</div>';
                return;
            }
            const sourcesDiv = document.createElement('div');
            sourcesDiv.className = 'vstack gap-2';
            extracted.forEach(x => {
                const dateStr = new Date(x.source_published_date).toLocaleDateString('en-US', {
                    month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
                const addl = x.additional_infos && Object.entries(x.additional_infos).length
                    ? Object.entries(x.additional_infos).map(([k, v]) => `<span class=\"badge text-bg-light me-1 mb-1\">"${k}: ${v}"</span>`).join(' ')
                    : '';
                const domain = extractDomain(x.source_url);
                const displayTitle = x.source_title ? `${domain}: ${x.source_title}` : `${domain}: Article`;
                const linkUrl = x.snippet ? `${x.source_url}#:~:text=${encodeURIComponent(x.snippet)}` : x.source_url;
                const sourceItem = document.createElement('div');
                sourceItem.className = 'source-item';
                // TODO: remove false && to re-activate additional infos
                sourceItem.innerHTML = `
                    <div class="d-flex align-items-start">
                      <div class="icon-placeholder icon-web me-2">üîó</div>
                      <div class="flex-grow-1">
                        <div class="fw-semibold small">
                          <a href="${linkUrl}" target="_blank" rel="noopener noreferrer" class="text-decoration-none">
                            ${displayTitle}
                          </a>
                        </div>
                        <div class="small text-secondary">
                          üìÖ Published ${dateStr} ‚Ä¢ üîó hops: ${x.degrees_of_separation}
                        </div>
                        ${x.snippet ? `<div class="mt-1 small text-muted">
                          <i>"${x.snippet}"</i>
                        </div>` : ''}
                        ${false && addl ? `<div class="mt-1 text-overflow-container"><div class="badge-container">${addl}</div></div>` : ''}
                      </div>
                    </div>
                `;
                sourcesDiv.appendChild(sourceItem);
            });
            container.innerHTML = '';
            container.appendChild(sourcesDiv);
        }

        function startPolling(topicIds) {
            console.log('Starting polling with 5 minute intervals (300000ms)');
            setInterval(async () => {
                console.log('Polling for updates...', new Date().toLocaleTimeString());
                try {
                    const pairs = await Promise.all(topicIds.map(async (tid) => {
                        const limit = topicState[tid]?.events?.length || 20;
                        const [events, count] = await Promise.all([
                            fetchUpcomingEvents(tid, limit, true, 0),
                            fetchEventsCount(tid)
                        ]);
                        return [tid, events, count];
                    }));
                    for (const [tid, events, count] of pairs) {
                        if (!topicState[tid]) continue;
                        topicState[tid].events = events;
                        topicState[tid].totalCount = count;
                        renderEventsForTopic(tid);
                    }
                } catch (e) {
                    console.error('Polling failed', e);
                }
            }, 300000);
        }

        // Global collapse/expand functionality
        const collapseAllSwitch = document.getElementById('collapse-all-switch');
        const collapseAllLabel = document.querySelector('label[for="collapse-all-switch"]');

        function updateCollapseAllSwitch() {
            const allTopicIds = Object.keys(topicState);
            const expandedCount = allTopicIds.filter(id => topicState[id]?.isExpanded).length;

            if (expandedCount === allTopicIds.length && allTopicIds.length > 0) {
                collapseAllSwitch.checked = true;
                collapseAllLabel.textContent = 'Expand all topics';
            } else if (expandedCount === 0 && allTopicIds.length > 0) {
                collapseAllSwitch.checked = false;
                collapseAllLabel.textContent = 'Collapse all topics';
            } else {
                // Mixed state - some expanded, some collapsed
                collapseAllSwitch.checked = false;
                collapseAllLabel.textContent = 'Expand all topics';
            }
        }

        collapseAllSwitch.onchange = () => {
            const shouldExpand = collapseAllSwitch.checked;
            const allTopicIds = Object.keys(topicState);

            allTopicIds.forEach(topicId => {
                // Update topic state
                topicState[topicId].isExpanded = shouldExpand;

                // Update UI elements
                const topicContent = document.querySelector(`#topic-content-${topicId}`);
                const collapseIndicator = document.querySelector(`#collapse-indicator-${topicId} .collapse-arrow`);
                const topicHeader = document.querySelector(`#topic-header-${topicId}`);

                if (topicContent) {
                    if (shouldExpand) {
                        topicContent.classList.add('show');
                    } else {
                        topicContent.classList.remove('show');
                    }
                }

                if (collapseIndicator) {
                    collapseIndicator.textContent = shouldExpand ? '‚ñº' : '‚ñ∂';
                }

                if (topicHeader) {
                    topicHeader.setAttribute('aria-expanded', shouldExpand ? 'true' : 'false');
                }

                // Also update sources and events collapses
                const sourcesContent = document.querySelector(`#sources-content-${topicId}`);
                const eventsContent = document.querySelector(`#events-content-${topicId}`);
                const sourcesSwitch = document.querySelector(`#sources-expand-${topicId}`);
                const eventsSwitch = document.querySelector(`#events-expand-${topicId}`);

                if (sourcesContent) {
                    if (shouldExpand) sourcesContent.classList.add('show');
                    else sourcesContent.classList.remove('show');
                }
                if (eventsContent) {
                    if (shouldExpand) eventsContent.classList.add('show');
                    else eventsContent.classList.remove('show');
                }
                if (sourcesSwitch) {
                    sourcesSwitch.checked = shouldExpand;
                    const sourcesLabel = document.querySelector(`label[for="sources-expand-${topicId}"]`);
                    if (sourcesLabel) sourcesLabel.textContent = shouldExpand ? 'Expand' : 'Collapse';
                }
                if (eventsSwitch) {
                    eventsSwitch.checked = shouldExpand;
                    const eventsLabel = document.querySelector(`label[for="events-expand-${topicId}"]`);
                    if (eventsLabel) eventsLabel.textContent = shouldExpand ? 'Collapse' : 'Expand';
                }
            });

            collapseAllLabel.textContent = shouldExpand ? 'Expand all topics' : 'Collapse all topics';
        };

        fetchTopics();
    </script>
</body>

</html>